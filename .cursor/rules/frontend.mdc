---
globs: *.tsx,*.ts,*.jsx,*.js
description: Frontend development patterns for React, Next.js, and Chrome extension
---

# Frontend Development

## React Component Architecture

### Component Structure
Follow the established patterns in [AuthProvider.tsx](mdc:dashboard/src/components/providers/AuthProvider.tsx):

```typescript
// âœ… Good: Well-structured React component
interface ComponentProps {
  title: string;
  children: React.ReactNode;
  onAction?: () => void;
  className?: string;
}

export function Component({ title, children, onAction, className }: ComponentProps) {
  const [state, setState] = useState<StateType>(initialState);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  // Event handlers
  const handleAction = useCallback(async () => {
    if (!onAction) return;
    
    setLoading(true);
    setError(null);
    
    try {
      await onAction();
    } catch (err) {
      setError(err instanceof Error ? err.message : 'An error occurred');
    } finally {
      setLoading(false);
    }
  }, [onAction]);

  // Effects
  useEffect(() => {
    // Side effects
  }, [dependencies]);

  return (
    <div className={cn("base-styles", className)}>
      <h2>{title}</h2>
      {error && <div className="error-message">{error}</div>}
      {loading && <div className="loading-spinner">Loading...</div>}
      {children}
    </div>
  );
}
```

### Custom Hooks
```typescript
// âœ… Good: Custom hooks for business logic
export function useAuth() {
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const login = useCallback(async (credentials: LoginCredentials) => {
    setLoading(true);
    setError(null);
    
    try {
      const response = await fetch('/api/auth/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(credentials)
      });
      
      if (!response.ok) {
        throw new Error('Login failed');
      }
      
      const data = await response.json();
      setUser(data.user);
      return data;
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Login failed');
      throw err;
    } finally {
      setLoading(false);
    }
  }, []);

  const logout = useCallback(async () => {
    try {
      await fetch('/api/auth/logout', { method: 'POST' });
      setUser(null);
    } catch (err) {
      console.error('Logout error:', err);
    }
  }, []);

  return { user, loading, error, login, logout };
}
```

## Next.js App Router Patterns

### Page Components
```typescript
// âœ… Good: Next.js page component structure
import { Metadata } from 'next';
import { Suspense } from 'react';

export const metadata: Metadata = {
  title: 'Dashboard | Quirkly',
  description: 'Manage your Quirkly account and settings',
  robots: 'noindex, nofollow' // For authenticated pages
};

interface PageProps {
  searchParams: { [key: string]: string | string[] | undefined };
}

export default async function DashboardPage({ searchParams }: PageProps) {
  // Server-side data fetching
  const initialData = await fetchDashboardData();
  
  return (
    <div className="dashboard-container">
      <Suspense fallback={<DashboardSkeleton />}>
        <DashboardContent initialData={initialData} />
      </Suspense>
    </div>
  );
}

// âœ… Good: Loading and error boundaries
function DashboardSkeleton() {
  return (
    <div className="animate-pulse">
      <div className="h-8 bg-gray-200 rounded w-1/4 mb-4"></div>
      <div className="space-y-3">
        {Array.from({ length: 5 }).map((_, i) => (
          <div key={i} className="h-4 bg-gray-200 rounded"></div>
        ))}
      </div>
    </div>
  );
}
```

### Layout Components
```typescript
// âœ… Good: Layout component with providers
import { AuthProvider } from '@/components/providers/AuthProvider';
import { Toaster } from 'react-hot-toast';

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en" className="dark">
      <body className="min-h-screen bg-background font-sans antialiased">
        <AuthProvider>
          <div className="relative flex min-h-screen flex-col">
            <header className="sticky top-0 z-50 w-full border-b bg-background/95 backdrop-blur supports-[backdrop-filter]:bg-background/60">
              <Navigation />
            </header>
            <main className="flex-1">
              {children}
            </main>
            <footer className="border-t py-6 md:py-0">
              <Footer />
            </footer>
          </div>
          <Toaster position="top-right" />
        </AuthProvider>
      </body>
    </html>
  );
}
```

## UI Component Design

### Reusable Components
```typescript
// âœ… Good: Reusable UI components with variants
import { cva, type VariantProps } from 'class-variance-authority';
import { cn } from '@/lib/utils';

const buttonVariants = cva(
  "inline-flex items-center justify-center rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:opacity-50 disabled:pointer-events-none ring-offset-background",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive: "bg-destructive text-destructive-foreground hover:bg-destructive/90",
        outline: "border border-input hover:bg-accent hover:text-accent-foreground",
        secondary: "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "underline-offset-4 hover:underline text-primary",
      },
      size: {
        default: "h-10 py-2 px-4",
        sm: "h-9 px-3 rounded-md",
        lg: "h-11 px-8 rounded-md",
        icon: "h-10 w-10",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
);

interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean;
}

export function Button({ className, variant, size, asChild = false, ...props }: ButtonProps) {
  return (
    <button
      className={cn(buttonVariants({ variant, size, className }))}
      {...props}
    />
  );
}
```

### Form Components
```typescript
// âœ… Good: Form components with validation
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';

const formSchema = z.object({
  email: z.string().email('Invalid email address'),
  password: z.string().min(8, 'Password must be at least 8 characters'),
  confirmPassword: z.string()
}).refine((data) => data.password === data.confirmPassword, {
  message: "Passwords don't match",
  path: ["confirmPassword"],
});

type FormData = z.infer<typeof formSchema>;

export function LoginForm() {
  const [loading, setLoading] = useState(false);
  const { login } = useAuth();
  
  const {
    register,
    handleSubmit,
    formState: { errors },
    setError
  } = useForm<FormData>({
    resolver: zodResolver(formSchema)
  });

  const onSubmit = async (data: FormData) => {
    setLoading(true);
    
    try {
      await login(data);
    } catch (error) {
      setError('root', {
        message: error instanceof Error ? error.message : 'Login failed'
      });
    } finally {
      setLoading(false);
    }
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)} className="space-y-4">
      <div>
        <label htmlFor="email" className="block text-sm font-medium">
          Email
        </label>
        <input
          {...register('email')}
          type="email"
          className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500"
        />
        {errors.email && (
          <p className="mt-1 text-sm text-red-600">{errors.email.message}</p>
        )}
      </div>
      
      <div>
        <label htmlFor="password" className="block text-sm font-medium">
          Password
        </label>
        <input
          {...register('password')}
          type="password"
          className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500"
        />
        {errors.password && (
          <p className="mt-1 text-sm text-red-600">{errors.password.message}</p>
        )}
      </div>
      
      {errors.root && (
        <div className="text-sm text-red-600">{errors.root.message}</div>
      )}
      
      <Button type="submit" disabled={loading} className="w-full">
        {loading ? 'Signing in...' : 'Sign in'}
      </Button>
    </form>
  );
}
```

## Chrome Extension Development

### Content Script Integration
```typescript
// âœ… Good: Content script with proper error handling
class QuirklyExtension {
  private isInitialized = false;
  private observer: MutationObserver | null = null;
  private retryCount = 0;
  private maxRetries = 3;

  constructor() {
    this.init();
  }

  private async init() {
    try {
      await this.checkAuthentication();
      this.setupMutationObserver();
      this.injectUI();
      this.isInitialized = true;
      console.log('âœ… Quirkly extension initialized');
    } catch (error) {
      console.error('âŒ Extension initialization failed:', error);
      this.handleInitError(error);
    }
  }

  private async checkAuthentication() {
    return new Promise((resolve, reject) => {
      chrome.storage.sync.get(['quirklyApiKey', 'quirklyUser'], (result) => {
        if (result.quirklyApiKey && result.quirklyUser) {
          resolve(result);
        } else {
          reject(new Error('Not authenticated'));
        }
      });
    });
  }

  private setupMutationObserver() {
    this.observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        if (mutation.type === 'childList') {
          this.handleDOMChanges(mutation);
        }
      });
    });

    this.observer.observe(document.body, {
      childList: true,
      subtree: true
    });
  }

  private handleDOMChanges(mutation: MutationRecord) {
    mutation.addedNodes.forEach((node) => {
      if (node.nodeType === Node.ELEMENT_NODE) {
        const element = node as Element;
        if (this.isReplyComposer(element)) {
          this.injectReplyButtons(element);
        }
      }
    });
  }

  private isReplyComposer(element: Element): boolean {
    return element.querySelector('[data-testid="tweetTextarea_0"]') !== null;
  }

  private injectReplyButtons(composer: Element) {
    const existingButtons = composer.querySelector('.quirkly-buttons');
    if (existingButtons) return;

    const buttonContainer = document.createElement('div');
    buttonContainer.className = 'quirkly-buttons';
    buttonContainer.innerHTML = this.getButtonHTML();

    const textarea = composer.querySelector('[data-testid="tweetTextarea_0"]');
    if (textarea) {
      textarea.parentNode?.insertBefore(buttonContainer, textarea);
      this.attachButtonEvents(buttonContainer);
    }
  }

  private getButtonHTML(): string {
    const tones = ['professional', 'casual', 'humorous', 'empathetic', 'analytical', 'enthusiastic'];
    
    return tones.map(tone => `
      <button class="quirkly-tone-btn" data-tone="${tone}">
        ${this.getToneIcon(tone)} ${tone.charAt(0).toUpperCase() + tone.slice(1)}
      </button>
    `).join('');
  }

  private attachButtonEvents(container: Element) {
    container.querySelectorAll('.quirkly-tone-btn').forEach(button => {
      button.addEventListener('click', (e) => {
        e.preventDefault();
        const tone = (e.target as HTMLElement).dataset.tone;
        if (tone) {
          this.generateReply(tone);
        }
      });
    });
  }

  private async generateReply(tone: string) {
    try {
      const tweetText = this.extractTweetText();
      if (!tweetText) {
        this.showError('Could not extract tweet text');
        return;
      }

      this.showLoading(tone);
      
      const response = await this.callAPI('/api/reply/generate', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-API-Key': await this.getApiKey()
        },
        body: JSON.stringify({
          prompt: tweetText,
          tone: tone
        })
      });

      if (response.success) {
        this.insertReply(response.data.reply);
      } else {
        this.showError(response.message || 'Failed to generate reply');
      }
    } catch (error) {
      console.error('Reply generation error:', error);
      this.showError('Failed to generate reply');
    } finally {
      this.hideLoading();
    }
  }

  private async callAPI(endpoint: string, options: RequestInit) {
    const baseUrl = await this.getBaseUrl();
    const response = await fetch(`${baseUrl}${endpoint}`, options);
    
    if (!response.ok) {
      throw new Error(`API call failed: ${response.status}`);
    }
    
    return response.json();
  }

  private handleInitError(error: Error) {
    this.retryCount++;
    
    if (this.retryCount < this.maxRetries) {
      console.log(`Retrying initialization (${this.retryCount}/${this.maxRetries})`);
      setTimeout(() => this.init(), 1000 * this.retryCount);
    } else {
      console.error('Max retries reached, extension disabled');
      this.showError('Extension initialization failed');
    }
  }

  private showError(message: string) {
    // Show user-friendly error message
    console.error('Quirkly Error:', message);
  }

  private showLoading(tone: string) {
    // Show loading indicator
  }

  private hideLoading() {
    // Hide loading indicator
  }

  private insertReply(reply: string) {
    // Insert generated reply into composer
  }

  private extractTweetText(): string | null {
    // Extract original tweet text for context
    return null;
  }

  private async getApiKey(): Promise<string> {
    return new Promise((resolve) => {
      chrome.storage.sync.get(['quirklyApiKey'], (result) => {
        resolve(result.quirklyApiKey);
      });
    });
  }

  private async getBaseUrl(): Promise<string> {
    return new Promise((resolve) => {
      chrome.storage.sync.get(['quirklyBaseUrl'], (result) => {
        resolve(result.quirklyBaseUrl || 'https://quirkly.technioz.com');
      });
    });
  }

  private getToneIcon(tone: string): string {
    const icons = {
      professional: 'ðŸ’¼',
      casual: 'ðŸ˜Š',
      humorous: 'ðŸ˜„',
      empathetic: 'â¤ï¸',
      analytical: 'ðŸ§ ',
      enthusiastic: 'ðŸ”¥'
    };
    return icons[tone as keyof typeof icons] || 'ðŸ’¬';
  }

  public destroy() {
    if (this.observer) {
      this.observer.disconnect();
    }
    this.isInitialized = false;
  }
}

// Initialize extension
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', () => {
    new QuirklyExtension();
  });
} else {
  new QuirklyExtension();
}
```

## State Management

### Context Providers
```typescript
// âœ… Good: Context provider with proper typing
interface AuthContextType {
  user: User | null;
  loading: boolean;
  error: string | null;
  login: (credentials: LoginCredentials) => Promise<void>;
  logout: () => Promise<void>;
  refreshUser: () => Promise<void>;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export function AuthProvider({ children }: { children: React.ReactNode }) {
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const login = useCallback(async (credentials: LoginCredentials) => {
    setLoading(true);
    setError(null);
    
    try {
      const response = await fetch('/api/auth/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(credentials)
      });
      
      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.message || 'Login failed');
      }
      
      const data = await response.json();
      setUser(data.user);
      
      // Store token
      localStorage.setItem('auth_token', data.token);
      
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Login failed';
      setError(errorMessage);
      throw err;
    } finally {
      setLoading(false);
    }
  }, []);

  const logout = useCallback(async () => {
    try {
      await fetch('/api/auth/logout', { method: 'POST' });
    } catch (err) {
      console.error('Logout error:', err);
    } finally {
      setUser(null);
      localStorage.removeItem('auth_token');
    }
  }, []);

  const refreshUser = useCallback(async () => {
    const token = localStorage.getItem('auth_token');
    if (!token) {
      setLoading(false);
      return;
    }

    try {
      const response = await fetch('/api/auth/me', {
        headers: { 'Authorization': `Bearer ${token}` }
      });
      
      if (response.ok) {
        const data = await response.json();
        setUser(data.user);
      } else {
        localStorage.removeItem('auth_token');
        setUser(null);
      }
    } catch (err) {
      console.error('User refresh error:', err);
      localStorage.removeItem('auth_token');
      setUser(null);
    } finally {
      setLoading(false);
    }
  }, []);

  useEffect(() => {
    refreshUser();
  }, [refreshUser]);

  const value = useMemo(() => ({
    user,
    loading,
    error,
    login,
    logout,
    refreshUser
  }), [user, loading, error, login, logout, refreshUser]);

  return (
    <AuthContext.Provider value={value}>
      {children}
    </AuthContext.Provider>
  );
}

export function useAuth() {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
}
```

## Performance Optimization

### Code Splitting
```typescript
// âœ… Good: Dynamic imports for code splitting
import { lazy, Suspense } from 'react';

const Dashboard = lazy(() => import('@/components/Dashboard'));
const AdminPanel = lazy(() => import('@/components/AdminPanel'));

export function App() {
  return (
    <Suspense fallback={<div>Loading...</div>}>
      <Routes>
        <Route path="/dashboard" element={<Dashboard />} />
        <Route path="/admin" element={<AdminPanel />} />
      </Routes>
    </Suspense>
  );
}
```

### Memoization
```typescript
// âœ… Good: Use memoization for expensive operations
export function ExpensiveComponent({ data, filters }: Props) {
  const processedData = useMemo(() => {
    return data.filter(item => 
      filters.every(filter => filter(item))
    ).map(item => ({
      ...item,
      computed: expensiveComputation(item)
    }));
  }, [data, filters]);

  const handleClick = useCallback((id: string) => {
    // Handle click
  }, []);

  return (
    <div>
      {processedData.map(item => (
        <Item key={item.id} data={item} onClick={handleClick} />
      ))}
    </div>
  );
}
```

### Virtual Scrolling
```typescript
// âœ… Good: Virtual scrolling for large lists
import { FixedSizeList as List } from 'react-window';

export function VirtualizedList({ items }: { items: any[] }) {
  const Row = ({ index, style }: { index: number; style: React.CSSProperties }) => (
    <div style={style}>
      <Item data={items[index]} />
    </div>
  );

  return (
    <List
      height={600}
      itemCount={items.length}
      itemSize={80}
      width="100%"
    >
      {Row}
    </List>
  );
}
```